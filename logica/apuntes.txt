//01-static
  Si declaramos una propiedad o m√©todo de una clase como static, podremos acceder a estos sin la necesidad de instanciar dicha clase o prototipo.

  Este tipo de atributos/m√©todos no son exclusivos de JavaScript, sino de casi todos los lenguajes que soportan la programaci√≥n orientada a objetos.

  Declarando m√©todos y atributos static en JavaScript
  De la siguiente manera podemos declarar atributos o m√©todos como static dentro de una clase (aplicable tambi√©n a prototipos):

  class Patito {
    static sonidito = "cuak!";

    static hacerSonidito() {
      return "cuak! x2";
    }
  }

  // Por fuera de clase Patito, podemos acceder a lo siguiente sin crear alguna instancia:
  // Al atributo `sonidito`
  console.log(Patito.sonidito)

  // Al m√©todo `hacerSonidito`
  console.log(Patito.hacerSonidito());
  M√©todos static de la superclase Object
  El superprototipo Object posee algunos m√©todos de tipo static y como todos los objetos que creamos en JavaScript heredan funcionalidad de Object, podemos acceder a una lista de funciones static que vendr√°n por defecto en nuestros objetos creados.

  Obtener las llaves de un objeto
  El m√©todo keys del superprototipo Object nos permite obtener el nombre de las llaves de un objeto en una lista:

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.keys(objetito)
  ); // [ 'name', 'email', 'age' ]
  Podr√≠amos obtener lo mismo con el m√©todo getOwnPropertyNames:

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.getOwnPropertyNames(objetito)
  ); // [ 'name', 'email', 'age' ]
  Obtener los pares llave-valor de un objeto
  Con el m√©todo entries de Object conseguimos tener en listas separadas los llave-valor declarados en un objeto. Estas listas ser√°n almacenadas en otra lista:

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.entries(objetito)
  );

  /* > Impresi√≥n en consola:
  [
    [ 'name', 'Juanito' ],
    [ 'email', 'juanito@frijolitos.io' ],
    [ 'age', 18 ]
  ]
  */
  Conocer el l√≠mite de acceso de un objeto
  Existe un m√©todo static propio de Object que es muy interesante: el m√©todo getOwnPropertyDescriptors.

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.getOwnPropertyDescriptors(objetito)
  );
  Esto nos devuelve un objeto con los atributos de nuestro objeto inicial. Cada atributo contiene un objeto con el valor correspondiente a dicha propiedad, adem√°s de 3 propiedades adicionales: writable, configurable y enumerable.

  {
    name: {
      value: 'Juanito',
      writable: true,
      enumerable: true,
      configurable: true
    },
    email: {
      value: 'juanito@frijolitos.io',
      writable: true,
      enumerable: true,
      configurable: true
    },
    age: {
      value: 18,
      writable: true,
      enumerable: true,
      configurable: true
    }
  }
  Estas 3 propiedades son usadas por JavaScript internamente para indicar el l√≠mite de acceso y modificaci√≥n que tiene un objeto. Con esto podr√≠amos utilizar ciertas t√©cnicas para manejar el encapsulamiento (uno de los pilares de la POO) de los objetos seg√∫n lo que deseemos.

  Veamos m√°s ejemplos de los m√©todos est√°ticos del prototipo Object y sobre el comportamiento que puede tener this. üë®‚Äçüíª

  Contribuci√≥n creada por: Mart√≠n √Ålvarez (Platzi Contributor)

//02-static-prototipo-objet M√©todos est√°ticos del prototipo Object

  Veamos unos ejemplos usando los m√©todos est√°ticos del prototipo Object. Adem√°s, podremos observar que this puede comportarse diferente seg√∫n el contexto en donde se encuentre.

  Antes de ello, en una carpeta, crea un archivo main.js el cual debe estar vinculado a un index.html creado en la misma ruta. Editaremos estos archivos en Visual Studio Code (puedes utilizar tu editor preferido) para realizar nuestras implementaciones y visualizaremos los outputs en la consola del navegador.

  <!-- ARCHIVO HTML BASE -->
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso Intermedio de POO en JS</title>
  </head>
  <body>
    <h1>Curso Intermedio de POO en JS</h1>

    <script src="./main.js"></script>
  </body>
  </html>
  Comportamiento de this en m√©todos est√°ticos
  Vamos a crear un objeto con los siguientes atributos:

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      // `this` se usa para hacer referencia a la propiedad `approvedCourses`
      // del objeto en cuesti√≥n.
      this.approvedCourses.push(newCourse);
    }
  };
  Ahora, utilicemos el m√©todo entries del prototipo Object pas√°ndole como argumento nuestro objeto juan:

  console.log(
    Object.entries(juan)
  );

  /* > En consola obtenemos un output similar a este:
  [
    [ 'name', 'Juanito' ],
    [ 'age', 18 ],
    [ 'approvedCourses', [ 'Curso 1' ] ],
    [ 'addCourse', [Function: addCourse] ]
  ]
  */
  Como el resultado es un Array que contiene a otros del mismo tipo, podemos acceder a sus √≠ndices y sub√≠ndices respectivamente. Por tanto, si accedemos al √≠ndice donde est√° la funci√≥n addCourse y lo mostramos en consola, obtendr√≠amos lo siguiente:

  console.log(
    Object.entries(juan)[3][1]
  );

  /* > Mensaje en consola del navegador:
  *f addCourse(newCourse) {
    this.approvedCourses.push(newCourse);
  }*
  */
  Si podemos acceder a la funci√≥n de esta manera, en principio pensar√≠amos que es posible a√±adir un nuevo curso ejecutando la funci√≥n desde ah√≠; sin embargo, esto nos produce un error:

  Object.entries(juan)[3][1]("Curso 2");
  Inconvenientes con this en un objeto al ejecutar m√©todos est√°ticos
  Imprimamos en consola qu√© es this en cada ejecuci√≥n del m√©todo addCourse. Cambiemos la estructura del objeto juan:

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      // A d√≥nde a punta `this`:
      console.log("This", this);
      // Saber si el contexto de `this` tiene definida la propiedad `approvedCourses`:
      console.log("This.approvedCourses", this.approvedCourses);

      this.approvedCourses.push(newCourse);
    }
  };
  Nuevamente, a√±adamos un curso accediendo al m√©todo addCourse desde la ejecuci√≥n de Object.entries:

  Object.entries(juan)[3][1]('Curso 3');
  This apunta ahora al subarray creado por Object.entries y ya no hace referencia al objeto juan
  En el navegador podremos observar que this apunta en realidad al subarray ["addCourse", function addCourse] generado por entries y ya no al objeto juan. Es por ello que cuando la funci√≥n addCourse intenta ejecutarse no encuentra la propiedad approvedCourses en el subarray ["addCourse", function addCourse] que es donde ahora this hace referencia.

  Crear propiedades con accesibilidad editable
  Existe un m√©todo est√°tico del prototipo Object llamado defineProperty que no solo nos permite crear un atributo con su respectivo valor en un objeto, sino tambi√©n nos da la posibilidad de definir las propiedades writable, enumerable y configurable a nuestro gusto. Estas propiedades son las que limitan el acceso y modificaci√≥n en un objeto de JavaScript:

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);

      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "pruebaNASA", {
    value: "extraterrestres",
    writable: true,
    enumerable: true,
    configurable: true
  });
  Veamos un poco m√°s acerca de Object.defineProperty. ü§ìüí™

  Contribuci√≥n creada por: Mart√≠n √Ålvarez (Platzi Contributor)

//Object.defineProperty
  El m√©todo defineProperty de la superclase Object no solo nos permite definir nuevos atributos en un objeto, sino tambi√©n configurar las siguientes propiedades:

  Configurable: indica si el nuevo atributo puede ser eliminado.
  Enumerable: indica si el nuevo atributo podr√° ser mostrado mediante funciones que listen las propiedades de un objeto. Hay excepciones en las que igual puede ser visualizado un atributo que tenga definido como false la propiedad enumerable.
  Writable: indica si el nuevo atributo puede ser modificado de valor.
  Normalmente, estas propiedades por defecto son definidas como true por JavaScript, sin embargo, si generamos los atributos de un objeto con Object.defineProperty, podr√≠amos definirlas a nuestro gusto.

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "nombreNuevaPropiedad", {
    value: "JavaScript", // Valor que tendr√°
    enumerable: false,
    writable: true,
    configurable: false,
  });

  Accesibilidad a los atributos de un objeto
  Con configurable, enumerable y writable podemos limitar el acceso y modificaci√≥n de los atributos de un objeto. Veamos su funcionamiento mediante un par de ejemplos:

  Atributos que no puedan ser listados
  Definimos enumerable como false. Este atributo reci√©n creado no se podr√° visualizar si por ejemplo intentamos listar las llaves del objeto usando Object.keys:

  // Definimos el objeto
  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "navigator", { // Creamos un nuevo atributo
    value: "Chrome",
    enumerable: false,
    writable: true,
    configurable: true,
  });

  console.log( // Imprimimos las llaves del objeto
    Object.keys(juan)
  ); // [ 'name', 'age', 'approvedCourses', 'addCourse' ]

  Sin embargo, hay una excepci√≥n si usamos Object.getOwnPropertyNames:

  // Definimos el objeto
  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "navigator", { // Creamos un nuevo atributo
    value: "Chrome",
    enumerable: false, // üëÄ
    writable: true,
    configurable: true,
  });

  console.log( // Imprimimos las propiedades del objeto
    Object.getOwnPropertyNames(juan)
  ); // [ 'name', 'age', 'approvedCourses', 'addCourse', 'navigator' ] üëà Ya nos aparece

  Atributos que no se puedan eliminar
  Para ello definimos configurable como false en la nueva propiedad:

  // Definimos el objeto
  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "terminal", { // Creamos un nuevo atributo
    value: "WSL",
    enumerable: true,
    writable: true,
    configurable: false, // üëÄ
  });

  console.log( // Mostramos las propiedades del objeto previamente... üëÅüëÅ
    Object.keys(juan)
  ); // [ 'name', 'age', 'approvedCourses', 'addCourse', 'terminal' ]

  delete terminal; // Intentamos eliminar ‚ùå

  console.log( // Listamos los atributos para comprobar si se elimin√≥ `terminal` ü§î
    Object.keys(juan)
  ); // [ 'name', 'age', 'approvedCourses', 'addCourse', 'terminal' ] üëà NO se elimin√≥

  Atributos que no se puedan sobreescribir
  Definimos writable como false:

  // Definimos el objeto
  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "editor", { // Creamos un nuevo atributo
    value: "VSCode",
    enumerable: true,
    writable: false,
    configurable: true,
  });

  console.log(juan.editor); // "VSCode"

  juan.editor = "Atom"; // Intentamos sobreescribirlo

  console.log(juan.editor); // "VSCode" üëà No cambi√≥

  Qu√© es Object.seal y Object.freeze
  El m√©todo seal ‚Äúsella‚Äù un determinado objeto. Es decir:

  Impide que nuevas propiedades sean agregadas.
  Define como configurable: false todos los atributos del objeto, con lo que impide que sean borradas.
  Los atributos s√≠ pueden ser modificados, ya que la propiedad writable permanece asignado como true.
  // Definimos el objeto
  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.seal(juan); // "Sellamos" el objeto

  // Listamos para saber las llaves actuales:
  console.log(Object.keys(juan)); // [ 'name', 'age', 'approvedCourses', 'addCourse' ]

  delete age; // Intentamos eliminar un atributo del objeto

  // Listamos para observar si hubo cambios:
  console.log(Object.keys(juan)); // [ 'name', 'age', 'approvedCourses', 'addCourse' ]

  El m√©todo freeze ‚Äúcongela‚Äù un objeto. Es decir:

  Impide que se le agreguen nuevas propiedades.
  Impide que sean eliminadas propiedades ya existentes.
  Evita que sus propiedades writable, enumerable y configurable sean modificadas.
  // Definimos el objeto
  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);
      this.approvedCourses.push(newCourse);
    }
  };

  Object.freeze(juan); // "Congelamos" el objeto

  // Listamos para saber las llaves actuales:
  console.log(Object.keys(juan)); // [ 'name', 'age', 'approvedCourses', 'addCourse' ]

  delete approvedCourses; // Intentamos eliminar un atributo del objeto
  juan.name = "Carlitos"; // Intentamos sobreescribir el valor de este atributo

  // Listamos para observar si hubo cambios:
  console.log(Object.keys(juan)); // [ 'name', 'age', 'approvedCourses', 'addCourse' ]
  // Verificamos si cambi√≥ el valor de `name`:
  console.log(juan.name); // "Juanito"

  Conozcamos ahora c√≥mo funciona la memoria en JavaScript. ü§îüë®‚Äçüíª

  Contribuci√≥n creada por: Mart√≠n √Ålvarez (Platzi Contributor) con el aporte de Zajith Corro Viveros.

// funcion de la memoria en JS
  La memoria en JavaScript funciona de la siguiente manera:

  Las variables son referencias a un espacio en memoria.
  Los navegadores web usan dos tipos de memorias: Stack y Heap.
  La memoria Stack es muy r√°pida, pero sin tanto espacio. Aqu√≠ se guardan los valores primitivos (booleanos, strings, n√∫meros‚Ä¶).
  La memoria Heap es m√°s lenta, pero permite guardar enormes cantidades de informaci√≥n (son como los tornados: grandes, lentos y desordenados). En esta memoria guardamos los valores de los objetos
  C√≥mo es el almacenamiento de objetos en JavaScript
  Cuando creamos variables en JavaScript (aplicable a casi cualquier otro lenguaje), ejecutamos 2 procesos:

  El primero es la inicializaci√≥n, es decir, le decimos a JS que vamos a crear una nueva variable con un nombre en espec√≠fico.

  let name;
  Lo segundo es la asignaci√≥n: le indicamos a JavaScript que esa variable que generamos con ese nombre en espec√≠fico tiene un valor.

  let name; // Inicializaci√≥n
  name = "pepito"; // Asignaci√≥n

  let age = 28;
  El nombre de las variables y el valor de estas se almacenan en la memoria stack, excepto cuando trabajamos con objetos.

  Memoria Stack en JS
  En memoria, el nombre de las variables apuntan a sus respectivos valores, sin embargo, cuando el valor a almacenar es un objeto, apuntan a otro apuntador (pointer o puntero) y este es el que en realidad apuntar√° al objeto en s√≠ el cual se encontrar√° almacenado en la memoria heap.

  Los objetos son almacenados en la memoria HEAP de JavaScript
  Cu√°l es la forma incorrecta de copiar objetos
  Si intentamos copiar un objeto en otra variable de esta manera:

  const juanita = { // ORIGINAL
    age: 15,
    email: "juanita@juanita.com"
  }

  const nath = juanita; // COPIA
  Cuando intentemos editar los valores de los atributos del objeto copia, los atributos del objeto original se ver√°n igualmente afectados:

  // Objeto original antes
  console.log(juanita); // { age: 15, email: 'juanita@juanita.com' }

  // Editamos s√≥lo el objeto copia
  nath.age = 20;
  nath.email = "nath@email.com"
  console.log(nath); // { age: 20, email: 'nath@email.com' }

  // Objeto original despu√©s de editar el objeto copia:
  console.log(juanita); // { age: 20, email: 'nath@email.com' }
  Lo anterior sucede porque cuando copiamos un objeto lo que en realidad estamos copiando es su referencia en la memoria, en otras palabras copiamos a su apuntador o pointer. Por ello, al modificar los valores de las propiedades de la copia de un objeto tambi√©n afectamos al original.

  Cuando copiamos directamente un objeto en otra variable, en realidad copiamos su pointer o apuntador (JS)
  Entonces, ¬øC√≥mo solucionamos esto? Tenemos 2 formas de hacerlo en JavaScript: el shallow copy y el deep copy. Veamos a continuaci√≥n c√≥mo aplicar el primero. ü§îüí™

  Contribuci√≥n creada por: Mart√≠n √Ålvarez (Platzi Contributor)





