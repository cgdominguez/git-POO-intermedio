//01-static
  Si declaramos una propiedad o m√©todo de una clase como static, podremos acceder a estos sin la necesidad de instanciar dicha clase o prototipo.

  Este tipo de atributos/m√©todos no son exclusivos de JavaScript, sino de casi todos los lenguajes que soportan la programaci√≥n orientada a objetos.

  Declarando m√©todos y atributos static en JavaScript
  De la siguiente manera podemos declarar atributos o m√©todos como static dentro de una clase (aplicable tambi√©n a prototipos):

  class Patito {
    static sonidito = "cuak!";

    static hacerSonidito() {
      return "cuak! x2";
    }
  }

  // Por fuera de clase Patito, podemos acceder a lo siguiente sin crear alguna instancia:
  // Al atributo `sonidito`
  console.log(Patito.sonidito)

  // Al m√©todo `hacerSonidito`
  console.log(Patito.hacerSonidito());
  M√©todos static de la superclase Object
  El superprototipo Object posee algunos m√©todos de tipo static y como todos los objetos que creamos en JavaScript heredan funcionalidad de Object, podemos acceder a una lista de funciones static que vendr√°n por defecto en nuestros objetos creados.

  Obtener las llaves de un objeto
  El m√©todo keys del superprototipo Object nos permite obtener el nombre de las llaves de un objeto en una lista:

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.keys(objetito)
  ); // [ 'name', 'email', 'age' ]
  Podr√≠amos obtener lo mismo con el m√©todo getOwnPropertyNames:

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.getOwnPropertyNames(objetito)
  ); // [ 'name', 'email', 'age' ]
  Obtener los pares llave-valor de un objeto
  Con el m√©todo entries de Object conseguimos tener en listas separadas los llave-valor declarados en un objeto. Estas listas ser√°n almacenadas en otra lista:

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.entries(objetito)
  );

  /* > Impresi√≥n en consola:
  [
    [ 'name', 'Juanito' ],
    [ 'email', 'juanito@frijolitos.io' ],
    [ 'age', 18 ]
  ]
  */
  Conocer el l√≠mite de acceso de un objeto
  Existe un m√©todo static propio de Object que es muy interesante: el m√©todo getOwnPropertyDescriptors.

  const objetito = {
      name: "Juanito",
      email: "juanito@frijolitos.io",
      age: 18,
  }

  console.log(
    Object.getOwnPropertyDescriptors(objetito)
  );
  Esto nos devuelve un objeto con los atributos de nuestro objeto inicial. Cada atributo contiene un objeto con el valor correspondiente a dicha propiedad, adem√°s de 3 propiedades adicionales: writable, configurable y enumerable.

  {
    name: {
      value: 'Juanito',
      writable: true,
      enumerable: true,
      configurable: true
    },
    email: {
      value: 'juanito@frijolitos.io',
      writable: true,
      enumerable: true,
      configurable: true
    },
    age: {
      value: 18,
      writable: true,
      enumerable: true,
      configurable: true
    }
  }
  Estas 3 propiedades son usadas por JavaScript internamente para indicar el l√≠mite de acceso y modificaci√≥n que tiene un objeto. Con esto podr√≠amos utilizar ciertas t√©cnicas para manejar el encapsulamiento (uno de los pilares de la POO) de los objetos seg√∫n lo que deseemos.

  Veamos m√°s ejemplos de los m√©todos est√°ticos del prototipo Object y sobre el comportamiento que puede tener this. üë®‚Äçüíª

  Contribuci√≥n creada por: Mart√≠n √Ålvarez (Platzi Contributor)

//02-static-prototipo-objet M√©todos est√°ticos del prototipo Object

  Veamos unos ejemplos usando los m√©todos est√°ticos del prototipo Object. Adem√°s, podremos observar que this puede comportarse diferente seg√∫n el contexto en donde se encuentre.

  Antes de ello, en una carpeta, crea un archivo main.js el cual debe estar vinculado a un index.html creado en la misma ruta. Editaremos estos archivos en Visual Studio Code (puedes utilizar tu editor preferido) para realizar nuestras implementaciones y visualizaremos los outputs en la consola del navegador.

  <!-- ARCHIVO HTML BASE -->
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso Intermedio de POO en JS</title>
  </head>
  <body>
    <h1>Curso Intermedio de POO en JS</h1>

    <script src="./main.js"></script>
  </body>
  </html>
  Comportamiento de this en m√©todos est√°ticos
  Vamos a crear un objeto con los siguientes atributos:

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      // `this` se usa para hacer referencia a la propiedad `approvedCourses`
      // del objeto en cuesti√≥n.
      this.approvedCourses.push(newCourse);
    }
  };
  Ahora, utilicemos el m√©todo entries del prototipo Object pas√°ndole como argumento nuestro objeto juan:

  console.log(
    Object.entries(juan)
  );

  /* > En consola obtenemos un output similar a este:
  [
    [ 'name', 'Juanito' ],
    [ 'age', 18 ],
    [ 'approvedCourses', [ 'Curso 1' ] ],
    [ 'addCourse', [Function: addCourse] ]
  ]
  */
  Como el resultado es un Array que contiene a otros del mismo tipo, podemos acceder a sus √≠ndices y sub√≠ndices respectivamente. Por tanto, si accedemos al √≠ndice donde est√° la funci√≥n addCourse y lo mostramos en consola, obtendr√≠amos lo siguiente:

  console.log(
    Object.entries(juan)[3][1]
  );

  /* > Mensaje en consola del navegador:
  *f addCourse(newCourse) {
    this.approvedCourses.push(newCourse);
  }*
  */
  Si podemos acceder a la funci√≥n de esta manera, en principio pensar√≠amos que es posible a√±adir un nuevo curso ejecutando la funci√≥n desde ah√≠; sin embargo, esto nos produce un error:

  Object.entries(juan)[3][1]("Curso 2");
  Inconvenientes con this en un objeto al ejecutar m√©todos est√°ticos
  Imprimamos en consola qu√© es this en cada ejecuci√≥n del m√©todo addCourse. Cambiemos la estructura del objeto juan:

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      // A d√≥nde a punta `this`:
      console.log("This", this);
      // Saber si el contexto de `this` tiene definida la propiedad `approvedCourses`:
      console.log("This.approvedCourses", this.approvedCourses);

      this.approvedCourses.push(newCourse);
    }
  };
  Nuevamente, a√±adamos un curso accediendo al m√©todo addCourse desde la ejecuci√≥n de Object.entries:

  Object.entries(juan)[3][1]('Curso 3');
  This apunta ahora al subarray creado por Object.entries y ya no hace referencia al objeto juan
  En el navegador podremos observar que this apunta en realidad al subarray ["addCourse", function addCourse] generado por entries y ya no al objeto juan. Es por ello que cuando la funci√≥n addCourse intenta ejecutarse no encuentra la propiedad approvedCourses en el subarray ["addCourse", function addCourse] que es donde ahora this hace referencia.

  Crear propiedades con accesibilidad editable
  Existe un m√©todo est√°tico del prototipo Object llamado defineProperty que no solo nos permite crear un atributo con su respectivo valor en un objeto, sino tambi√©n nos da la posibilidad de definir las propiedades writable, enumerable y configurable a nuestro gusto. Estas propiedades son las que limitan el acceso y modificaci√≥n en un objeto de JavaScript:

  const juan = {
    name: "Juanito",
    age: 18,
    approvedCourses: ["Curso 1"],
    addCourse(newCourse) {
      console.log("This", this);
      console.log("This.approvedCourses", this.approvedCourses);

      this.approvedCourses.push(newCourse);
    }
  };

  Object.defineProperty(juan, "pruebaNASA", {
    value: "extraterrestres",
    writable: true,
    enumerable: true,
    configurable: true
  });
  Veamos un poco m√°s acerca de Object.defineProperty. ü§ìüí™

  Contribuci√≥n creada por: Mart√≠n √Ålvarez (Platzi Contributor)












